## 一. Python基础

### 1 语法

#### 1.1 输入与输出

##### 1.1.1 代码中修改不可变数据类型会出现什么问题?

```python
a = 'abc'
print(a[0])
a[0] = 'b'
```

> TypeError: str object does not support item assignment

##### 1.1.2 a=1,b=2,不用中间变量交换a,b的值?

方法一:

```python
a = a+b
b = a-b
a = a-b
```

方法二:

```python
a, b = b, a 
```

##### 1.1.3 pirnt调用底层什么方法?

print 方法默认调用 sys.stdout.write 方法,即往控制台打印字符串

##### 1.1.4 简述input()函数理解?

input()获取用户输入,不论用户输入的是什么,获取到的都是字符串类型

#### 1.2 条件与循环

##### 1.2.1 range和xrange的区别?

两者用法相同,不同的是 range 返回的结果是一个列表,而 xrange 的结果是一个生成器,前者是直接开辟一块内存空间来保存列表,后者是边循环边使用,只有使用时才会开辟内存空间,所以当列表很长时,使用 xrange 性能要比range好,Python3中没有xrange函数

#### 1.3 文件操作

##### 1.3.1 4G内存如何读取5G文件?

可以通过生成器,分多次读取,每次读取数量相对少的数据(比如500MB)进行处理,处理结束后在读取后面的500MB的数据

##### 1.3.2 read、readline和readlines的区别?

read:读取整个文件
readline:读取下一行,使用生成器方法
readlines:读取整个文件到一个迭代器以供我们遍历

#### 1.4 异常

##### 1.4.1 在except中return后还会不会执行finally中的代码?怎么抛出自定义异常?

会继续处理 finally 中的代码,用 raise 方法可以抛出自定义异常

##### 1.4.2 介绍一下 except 的作用和用法？

except: 捕获所有异常 
except: <异常名>: 捕获指定异常 
except: <异常名 1, 异常名 2> : 捕获异常1或者异常 2 
except: <异常名>,<数据>:捕获指定异常及其附加的数据 
except: <异常名 1,异常名 2>:<数据>:捕获异常名1或者异常名2,及附加的数据

#### 1.5 模块与包

##### 1.5.1 常用的Python标准库都有哪些?

os 操作系统、time 时间、random 随机、pymysql 连接数据库、threading 线程、multiprocessing进程、queue 队列

##### 1.5.2 赋值、浅拷贝和深拷贝的区别?

```python
import copy
a = [1, 2, 3, 4, ['a', 'b']]  #原始对象

b = a  #赋值,传对象的引用,赋值引用,a和b都指向同一个对象 # TODO:引用赋值,与传值赋值区分
c = copy.copy(a)  #对象拷贝,浅拷贝  #  浅拷贝,a和c是一个独立的对象,但他们的子对象还是指向统一对象(是引用),只拷贝顶级对象,或者说父级对象
d = copy.deepcopy(a)  #对象拷贝,深拷贝  #  深拷贝,a和b完全拷贝了父对象及其子对象,两者是完全独立的 ,拷贝所以对象,顶级对象及其嵌套对象 # TODO: 传值赋值

a.append(5)  #修改对象a  #a = [1, 2, 3, 4, ['a', 'b'],5]
a[4].append('c')  #修改对象a中的['a', 'b']数组对象  #a = [1, 2, 3, 4, ['a', 'b','c'],5]

print('a = ', a)
print('b = ', b)
print('c = ', c)
print('d = ', d)

# 输出结果:
a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
c =  [1, 2, 3, 4, ['a', 'b', 'c']]
d =  [1, 2, 3, 4, ['a', 'b']]
```

**赋值**
在Python中,对象的赋值就是简单的对象引用

```python
a = b
```

在上述情况下, a 和 b 是一样的,他们指向同一片内存, b 不过是 a 的别名,是引用
我们可以使用 b is a 去判断,返回 True,表明他们地址相同,内容相同,也可以使用 id() 函数来查看两个列表的地址是否相同
赋值操作(包括对象作为参数、返回值)不会开辟新的内存空间,它只是复制了对象的引用,也就是说除了 b 这个名字之外,没有其他的内存开销,修改了 a,也就影响了 b,同理,修改了 b 也就影响了 a

**浅拷贝**
浅拷贝会创建新对象,其内容非原对象本身的引用,而是原对象内第一层对象的引用 
浅拷贝有三种形式:切片操作、工厂函数、copy 模块中的 copy 函数 
比如上述的列表 a 
切片操作:b = a[:] 或者 b = [x for x in a] 
工厂函数:b = list(a) 
copy 函数:b = copy.copy(a) 
浅拷贝产生的列表 b 不再是列表 a 了,使用 is 判断可以发现他们不是同一个对象,使用 id 查看, 他们也不指向同一片内存空间但是当我们使用 id(x) for x in a 和 id(x) for x in b 来查看 a 和 b 中元 素的地址时,可以看到二者包含的元素的地址是相同的
在这种情况下,列表 a 和 b 是不同的对象,修改列表 b 理论上不会影响到列表 a 但是要注意的是,浅拷贝之所以称之为浅拷贝,是它仅仅只拷贝了一层,在列表 a 中有一个嵌套的 list,如果我们修改了它,情况就不一样了
比如：a[4].append('c'),查看列表 c,会发现列表 c 也发生了变化,这是因为,我们修改了嵌套的 list,修改外层元素,会修改它的引用,让它们指向别的位置,修改嵌套列表中的元素,列表的地址并未发生变化,指向的都是用一个位置

**深拷贝**
深拷贝只有一种形式,copy 模块中的 deepcopy() 函数,深拷贝和浅拷贝对应,深拷贝拷贝了对象的所有元素,包括多层嵌套的元素.因此,它的时间和空间开销要高,同样的对列表 a,如果使用 d = copy.deepcopy(a),再修改列表 d 将不会影响到列表 a,即使嵌套的列表具有更深的层次,也不会产生任何影响,因为深拷贝拷贝出来的对象根本就是一个全新的对象, 不再与原来的对象有任何的关联

**拷贝的注意点**
对于非容器类型,如数字、字符,以及其他的原子类型,没有拷贝一说,产生的都是原对象的引用
如果元组变量值包含原子类型对象,即使采用了深拷贝,也只能得到浅拷贝

##### 1.5.3 \__init__和new的区别?

init 在对象创建后,对对象进行初始化
new 是在对象创建之前创建一个对象,并将该对象返回给 init

##### 1.5.4 Python中如何生成随机数?

在Python中用于生成随机数的模块是 random,在使用前需要 import

```python
import random

# 生成一个 0-1 之间的随机浮点数
print(random.random())
# 生成[a,b]之间的浮点数
print(random.uniform(1.1, 1.2))
# 生成[a,b]之间的整数
print(random.randint(2, 5))
# 从特定序列中随机取一个元素,这里的序列可以是字符串、列表、元组等
print(random.choice('12345'))

```

##### 1.5.5 输入某年某月某日,判断这一天是这一年的第几天?

在Python中用于日期模块是 datetime,在使用前需要 import

```python
import datetime 

def dayofyear(): 
    year = input('请输入年份:') 
    month = input('请输入月份:') 
    day = input('请输入天:') 
    date1 = datetime.date(year=int(year),month=int(month),day=int(day)) 
    date2 = datetime.date(year=int(year),month=1,day=1) 
                  
    return (date1 - date2 + 1).days
                  
```

##### 1.5.6 打乱一个排好序的list对象ls?

```python
import random

ls = [1,2,3,4,5]
print(random.shuffle(ls))

```

##### 1.5.7 说明一下 os.path 和 sys.path 分别代表什么?

os.path 主要是用于对系统路径文件的操作
sys.path 主要是对 Python 解释器的系统环境参数的操作(动态的改变 Python 解释器搜索路径)

##### 1.5.8 Python 中的 os 模块常见方法?

os.remove() 删除文件 
os.rename() 重命名文件
os.getcwd() 取得当前工作目录
os.path.join() 将分离的各部分组合成一个路径名
os.path.exists() 是否存在
os.path.getsize() 返回文件大小
os.path.isfile()是否为文件

##### 1.5.9 Python 的 sys 模块常用方法?

sys.argv 命令行参数 List,第一个元素是程序本身路径
sys.modules.keys() 返回所有已经导入的模块列表
sys.path 返回模块的搜索路径,初始化时使用 PYTHONPATH 环境变量的值

##### 1.5.10 模块和包是什么?

在 Python 中,模块是搭建程序的一种方式
每一个 Python 代码文件都是一个模块,并可以引用 其他的模块,比如对象和属性,一个包含许多 Python 代码的文件夹是一个包,一个包可以包含模块和子文件夹

#### 1.6 Python特性

##### 1.6.1 Python 是强语言类型还是弱语言类型?

Python 是强类型的动态脚本语言
强类型:不允许不同类型相加 
动态:不使用显示数据类型声明,且确定一个变量的类型是在第一次给它赋值的时候
脚本语言:一般也是解释型语言,运行代码只需要一个解释器,不需要编译

##### 1.6.2 Python 是如何进行类型转换的?

内建函数封装了各种转换函数,可以使用目标类型关键字强制类型转换
进制之间的转换可以用 int('str', base='n')将特定进制的字符串转换为十进制,再用相应的进制转换函数将十进制转换为目标进制

可以使用内置函数直接转换的有
list---->tuple tuple(list)
tuple---->list list(tuple)

##### 1.6.3 Python 中的作用域?

Python 中,一个变量的作用域总是由在代码中被赋值的地方所决定
当 Python 遇到一个变量的话，它会按照这的顺序进行搜索
本地作用域(Local)--->当前作用域被嵌入的本地作用域(Enclosing locals)--->全局/模块作用域 (Global)--->内置作用域(Built-in)

### 2 数据类型

#### 2.1 string

##### 2.1.1 什么是可变、不可变数据类型?

可变不可变指的是内存中的值是否可以被改变
不可变类型指的是对象所在内存块里面的值不可以改变,有数值、字符串、元组
可变类型则是可以改变,主要有列表、字典、集合

##### 2.1.2 如何理解 Python 中字符串中的\字符?

有三种不同的含义
1.转义字符
2.路径名中用来连接路径名
3.编写太长代码手动软换行

##### 2.1.3 写过反转字符串的方法

方法一 切片

```python
str = '12345'

pirnt(str[::-1])

```

方法二 列表reverse方法

```python
str = '12345'

ls = list(str)
ls.reverse()

print(''.join(ls))

```

方法三 列表推导

```python
str = '12345'

nstr = ''.join(str(-x) for x in range(1, len(str)+1))

```



##### 2.1.4 将字符串"k:1|k1:2|k2:3|k3:4"，处理成 Python 字典：{k:1， k1:2， ... } ,字典里的 k 作为字符串处理

##### 2.1.5 请按 ls 中元素的 age 由大到小排序

#### 2.2 tuple

tuple:元组,元组将多样的对象集合到一起,不能修改,通过索引进行查找,使用括号()
应用场景:把一些数据当做一个整体去使用,不能修改

```python
a = '1'
b = '1',

# string
pirnt(type(a))
# tuple
pirnt(type(b))

```

#### 2.3 list

list是 Python 中使用最频繁的数据类型,在其他语言中通常叫做数组,通过索引进行查找,使用方括号[], 列表是有序的集合

##### 2.3.1 列表常用操作

1) 增加

在指定位置插入数据 列表.insert(index, value)

```python
ls = [1, 2, 3, 4, 5]

# 列表下标为0的地方插入数据
ls.insert(0,0)

# 列表下标为6的地方插入数据,列表最大下标为4,自动补位插到最后位置
ls.insert(6,6)

```

在列表末尾追加数据 列表.append(value)

```python
ls = [1, 2, 3, 4, 5]

# 末尾追加
ls.append(6)

```

将可迭代对象追加到列表 列表.extend(iterable)

```python
str = '12345'
ls = []

ls.extend(str)

```

2)删除

删除指定索引数据 del 列表[index]

```python
ls = [1, 2, 3, 4, 5]

del ls[4]

```

删除第一个出现的指定元素 列表.remove(value)

```python
ls = [1, 2, 3, 4, 5]

ls.remove(5)

```

删除末尾数据 列表.pop() 返回值是被删除元素

```python
ls = [1, 2, 3, 4, 5]

ls.pop()

```

删除指定索引元素并返回此元素 列表.pop(index)

```python
ls = [1, 2, 3, 4, 5]

ls.pop(4)

```

清空列表元素 列表.clear()

```python
ls = [1, 2, 3, 4, 5]

ls.clear()

```

3)排序

升序排序 列表.sort(reverse=False)

```python
ls = [5, 4, 3, 2, 1]

ls.sort()

```

逆序反转 列表.reverse()

```python
ls = [5, 4, 3, 2, 1]

ls.reverse()

```

4)统计相关

数据在列表中出现的次数 列表.count(value)

```python
ls = [1, 2, 3, 4, 5]

ls.count(1)

```

##### 2.3.2 ls[10]和ls[10:]

尝试获取列表的切片,开始的 index 超过了成员个数不会产生 IndexError,而是仅仅返回一个空列表

```python
ls = [1, 2, 3, 4, 5]

# IndexError: list index out of range
print(ls[10])
# []
print(ls[10:])

```

##### 2.3.3 给定两个列表,怎么找出他们相同的元素和不同的元素?

```python
l1 = [1, 2, 3]
l2 = [3, 4, 5]

set1 = set(l1)
set2 = set(l2)

print(set1&set2)
print(set1^set2)

```

##### 2.3.4 列表去重

方法一 set去重

```python
ls = [1, 1, 2, 2, 3, 3, 4, 4]

nls = list(set(ls))
# key主要是用来进行比较的元素,只有一个参数,具体的函数的参数就是取自于可迭代对象中,指定可迭代对象中的一个元素来进行排序.
nls.sort(key=ls.index)

```

方法二 循环去重

```python
ls = [1, 1, 2, 2, 3, 3, 4, 4]

nls = []

for x in ls:
    if x not in nls:
        nls.append(x)
        
```

方法三 dict属性

```python
ls = [1, 1, 2, 2, 3, 3, 4, 4]

newdic = {}.fromkeys(ls)

nls = list(newdic)

```

#### 2.4 dict

##### 2.4.1 现有字典dic = {'a':5, 'b':4, 'c':3}请按字典中的 value 值进行排序?

```python
dic = {'a':5, 'b':4, 'c':3}

sorted(dic.items(),key = lambda x:x[1])
```

##### 2.4.2 字典和json的区别?

字典是一种数据结构,json 是一种数据的表现形式,字典的 key 值只要是能 hash 的就行,json 的必须是字符串

##### 2.4.3 字典推导式

```python
dic = {key: value for (key, value) in iterable}
```

##### 2.4.4 输出一个字符串中每个字符的个数

方法一 dict.get方法

```python
str = 'life is short I use python'

dic = dict()

for x in str:
    dic[x] = dic.get(x,0) + 1
    
print(dic)

# dict.get(Key,default=None),返回指定键的值,如果键不在字典中返回默认值为None或者设置的默认值

```

方法二 dict属性

```python
str = 'life is short I use python'

dic = dict()

for x in str:
    if x not in dic.keys():
        dic[x] = 1
    else:
        dic[x] += 1
        
print(dic)

```

#### 2.5 set

set 集合,在 Python 中的书写方式的{},集合与之前列表、元组类似,可以存储多个数据,但是这些数据是不重复的
集合对象还支持 union(联合), intersection(交), difference(差)和sysmmetric_difference(对称差集)等数学运算

##### 2.5.1 集合常用操作

1)列表去重

```python
ls = [1, 1, 2, 2, 3, 3, 4, 4]

set(ls)

```

2)交集(共有部分)

```python
a = {1, 2, 3, 4, 5}
b = {1, 3, 5, 7, 9}

print(a & b)

```

3)并集(总共部分)

```python
a = {1, 2, 3, 4, 5}
b = {1, 3, 5, 7, 9}

print(a|b)

```

4)差集(另一个集合中没有部分)

```python
a = {1, 2, 3, 4, 5}
b = {1, 3, 5, 7, 9}

print(a - b)
```

5)对称差集(在二者中,但不会同时出现在二者中)

```python
a = {1, 2, 3, 4, 5}
b = {1, 3, 5, 7, 9}

print(a ^ b)
```

## 二. Python高级

### 1 元类

#### 1.1 Python 中类方法、类实例方法、静态方法有何区别?

**类方法**
是类对象的方法,在定义时需要在上方使用'@classmethod'进行装饰,形参为 cls,表示类对象,类对象和实例对象都可调用 

**类实例方法**
是类实例化对象的方法,只有实例对象可以调用,形参为 self,指代对象本身

**静态方法**
是一个任意函数,在其上方使用'@staticmethod'进行装饰,可以用对象直接调用,静态方法实际上跟该类没有太大关系

### 2 内存管理和垃圾回收机制

#### 2.1 Python的内存管理机制及调优手段?

**内存管理机制:引用计数、垃圾回收、内存池**

**引用计数**

引用计数是一种非常高效的内存管理手段
当一个 Python 对象被引用时其引用计数增加 1,当其不再被一个变量引用时则计数减 1,当引用计数等于 0 时对象被删除

**垃圾回收**

+ 引用计数
  引用计数也是一种垃圾收集机制,而且也是一种最直观,最简单的垃圾收集技术
  当 Python 的某 个对象的引用计数降为 0 时,说明没有任何引用指向该对象,该对象就成为要被回收的垃圾了
  比如某个新建对象,它被分配给某个引用,对象的引用计数变为 1
  如果引用被删除,对象的引用计数为 0,那么该对象就可以被垃圾回收
  不过如果出现循环引用的话,引用计数机制就不再起有效的作用了
+ 标记清除
  如果两个对象的引用计数都为 1,但是仅仅存在他们之间的循环引用,那么这两个对象都是需要被回收的,也就是说,它们的引用计数虽然表现为非 0,但实际上有效的引用计数为 0,所以先将循环引用摘掉,就会得出这两个对象的有效计数
+ 分代回收
  从前面“标记-清除”这样的垃圾收集机制来看,这种垃圾收集机制所带来的额外操作实际上与系统中总的内存块的数量是相关的,当需要回收的内存块越多时,垃圾检测带来的额外操作就越多,而垃圾回收带来的额外操作就越少,反之,当需回收的内存块越少时,垃圾检测就将比垃圾回收带来更少的额外操作
  举个例子,当某些内存块 M 经过了 3 次垃圾收集的清洗之后还存活时,我们就将内存块 M 划到一个集合 A 中去,而新分配的内存都划分到集合 B 中去,当垃圾收集开始工作时,大多数情况都只对集合 B 进 行垃圾回收,而对集合 A 进行垃圾回收要隔相当长一段时间后才进行,这就使得垃圾收集机制需要处理的内存少了,效率自然就提高了,在这个过程中,集合 B 中的某些内存块由于存活时间长而会被转移到集合 A 中,当然集合 A 中实际上也存在一些垃圾,这些垃圾的回收会因为这种分代的机制而被延迟

#### 2.2 内存泄露是什么,如何避免?

内存泄露指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况
内存泄漏并非指内存在物理上的 消失,而是应用程序分配某段内存后,由于设计错误,失去了对该段内存的控制,因而造成了内存的浪 费,导致程序运行速度减慢甚至系统崩溃等严重后果
有 __del__() 函数的对象间的循环引用是导致内存泄漏的主凶,不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题,通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息,可以通过 sys.getrefcount(obj) 来获取对象的引用计数,并根据返回值是否为 0 来判断是否内存泄漏

### 3 函数

#### 3.1 函数参数

##### 3.1.1 Python 函数调用的时候参数的传递方式是值传递还是引用传递?

**Python 的参数传递有:位置参数、默认参数、可变参数、关键字参数**

函数的传值到底是值传递还是引用传递，要分情况

不可变参数用值传递
像整数和字符串这样的不可变对象,是通过拷贝进行传递的,因为你无论如何都不可能在原处改变不可变对象

可变参数引用传递
比如像列表,字典这样的对象是通过引用传递、和 C 语言里面的用指针传递数组很相似,可变对象能在函数内部改变

##### 3.1.2 对缺省参数的理解

缺省参数指在调用函数的时候没有传入参数的情况下,调用默认的参数,在调用函数的同时赋值时,所传入的参数会替代默认参数 *args 是不定长参数,他可以表示输入参数是不确定的,可以是任意多个
**kwargs 是关键字参数,赋值的时候是以键 = 值的方式,参数是可以任意多对在定义函数的时候不确定会有多少参数会传入时,就可以使用两个参数

##### 3.1.3 为什么函数名字可以当做参数用?

Python 中一切皆对象,函数名是函数在内存中的空间,也是一个对象

##### 3.1.4 Python 中 pass 语句的作用是什么?

在编写代码时只写框架思路,具体实现还未编写就可以用 pass 进行占位,使程序不报错,不会进行任何操作

#### 3.2 内建函数

##### 3.2.1 filter、map函数和reduce函数?

1)从参数来讲
map()包含两个参数,第一个参数是一个函数,第二个是序列(列表或元组),其中,函数(即 map 的第一个参数位置的函数)可以接收一个或多个参数
reduce()第一个参数是函数,第二个是序列(列表或元组),但是,其函数必须接收两个参数

2)从对传进来的数值作用来讲
map()是将传入的函数依次作用到序列的每个元素,每个元素都是独自被函数作用一次
reduce()是将传入的函数作用在序列的第一个元素得到结果后,把这个结果继续与下一个元素作用(累积计算)

```python
# 筛选列表中大于5的元素
ls = [1, 2, 3, 4, 5]

nls = filter(lambda x:x>3, ls)

print(list(filter_ls))

```

```python
# 列表元素平方
ls = [1, 2, 3, 4, 5]

nls = map(lambda x:x**2, ls)

print(list(nls))

```

```python
# 求3阶乘
from functools import reduce

fact = reduce(lambda x,y:x*y,range(1,4))

print(fact)

```

##### 3.2.2 什么是 lambda 函数,有什么好处?

lambda 函数是一个可以接受任意多个参数(包括可选参数)并且返回单个表达式值函数,这种函数得名于省略了用 def 声明函数标准步骤 

1. lambda 函数比较轻便,即用即仍,适合需要完成一项功能,但此功能只在一处使用,连名字都很随意情况下
2. 匿名函数,一般用来给filter、map这样的函数式编程服务
3. 作为回调函数,传递给某些应用,比如消息处理

### 三. 设计模式

#### 3.1 单例

##### 3.1.1 手写单例

##### 3.1.2 单例模式应用场景

#### 3.2 装饰器

##### 3.2.1 什么是装饰器,手写一个计时器记录方法执行性能装饰器?

##### 3.2.2 什么是闭包?

在函数嵌套的前提下,内部函数使用了外部函数的变量,并且外部函数返回了内部函数,我们把这个使用外部函数变量的内部函数称为闭包

**闭包构成条件**
	函数嵌套(函数里面再定义函数)的前提下
	内部函数使用了外部函数的变量(还包括外部函数的参数)
	外部函数返回了内部函数,这个使用了外部函数变量的内部函数称之为闭包

##### 3.2.3 装饰器有什么作用?

#### 3.3 生成器

##### 3.3.1 生成器、迭代器区别？

### 四. 面向对象

#### 4.1 对象

##### 4.1.1 Python中的可变对象和不可变对象?

不可变对象,该对象所指向的内存中的值不能被改变
当改变某个变量时候,由于其所指的值不能被改变,相当于把原来的值复制一份后再改变,这会开辟一个新的地址,变量再指向这个新的地址
可变对象,该对象所指向的内存中的值可以被改变
变量(准确的说是引用)改变后,实际上是其所指的值直接发生改变,并没有发生复制行为,也没有开辟新的出地址,通俗点说就是原地改变

**Python 中,数值类型(int 和 float)、字符串 str、元组 tuple 都是不可变类型,而列表 list、字典 dict、集合 set 是可变类型**

##### 4.1.2 Python中 is 和 == 的区别?

is 判断的是 a 对象是否就是 b 对象,是通过 id 来判断的 
== 判断的是 a 对象的值是否和 b 对象的值相等,是通过 value 来判断的

##### 4.1.3 对面向对象的理解?

面向对象是相对于面向过程而言的,面向过程语言是一种基于功能分析的、以算法为中心的程序设计方法
而面向对象是一种基于结构分析的、以数据为中心的程序设计思想

**面向对象有三大特性:封装、继承、多态**

### 五. 正则表达式

#### 5.1 正则语法

##### 5.1.1 Python 中 match 和 serach 的区别?

##### 5.1.2 Python 中字符串查找和替换?

### 六. 系统编程

#### 6.1 谈谈多进程、多线程以及协程理解?

#### 6.2 Python 虚拟环境使用?

##### 6.2.1 什么是 Python 虚拟环境

一种采用协作式隔离的运行时环境,允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python 应用程序的行为

##### 6.2.2 venv 基本使用和原理

查看 venv 命令参数

> python -m venv -h

![image-20210401215357140](https://cdn.jsdelivr.net/gh/chanwanxiang/imageHosting/img/image-20210401215357140.png)

创建虚拟环境

> python -m venv venvdemo

![image-20210401215831406](https://cdn.jsdelivr.net/gh/chanwanxiang/imageHosting/img/image-20210401215831406.png)

虚拟环境原理

> 修改环境变量,把虚拟环境的Python路径加入环境变量最前,环境变量使用原则近者优先.

![image-20210401220456638](https://cdn.jsdelivr.net/gh/chanwanxiang/imageHosting/img/image-20210401220456638.png)

##### 6.2.3 保存和复制虚拟环境

虚拟环境依赖导出

> pip freeze > requirement.txt

![image-20210401220936652](https://cdn.jsdelivr.net/gh/chanwanxiang/imageHosting/img/image-20210401220936652.png)

### 七. 网络编程

#### 7.1 UDP 总结

#### 7.2 TCP 总结

#### 7.3 简述 TCP 和 UDP 区别以及优缺点?

#### 7.4 简述浏览器通过 wsgi 请求动态资源过程?

#### 7.5 简述浏览器访问 www.baidu.com 的过程?

#### 7.7 GET 和 POST 请求区别有哪一些?

#### 7.8 cookie 和 session 的区别?

#### 7.9 简单描述 TCP 三次握手和四次挥手?

#### 7.10 说说 HTTP 和 HTTPS 区别?

### 八. web开发

#### 8.1 django

##### 8.1.1 django 创建项目的命令?

> django-admin startproject 项目名称
> python manage.py startapp 应用名称

##### 8.1.2 django 创建项目后项目文件夹下的组成部分?

![image-20210416144220927](https://cdn.jsdelivr.net/gh/chanwanxiang/imageHosting/img/image-20210416144220927.png)

**项目文件夹的组成部分**

manage.py 是项目运行入口,指定配置文件路径
与项目同名的文件夹
\__init.py__ 是一个空文件,作用是这个目录可以被当做包使用
setting.py是项目整体配置文件
urls.py 是项目的 URL 配置文件
wsgi.py 是项目与 wsgi 兼容的web服务器

