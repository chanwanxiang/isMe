# TODO: 时间复杂度T
#     假设存在函数g,是的算法A处理规模为n的问题示例所用时间为T(n)=O(g(n)),则成O(g(n))为算法A的渐进时间负责度,
#     简称时间复杂度,记为T(n)

# 最坏时间复杂度
#     算法完成工作最少需要多少基本操作,即最优时间复杂度
#     算法完成工作最多需要多少基本操作,即最坏时间复杂度
#     算法完成工作平均需要多少基本操作,即平均时间复杂度
#     TODO: 对于最坏时间复杂度,提供了一种保证,表明算法在此种程度的基本操作中一定能完成工作
#     因此,对于算法时间复杂度我们主要关注最坏时间复杂度

# 时间复杂度的几条基本计算规则
#     1. 基本操作,即只有常数项,认为其时间复杂度为O(1)
#     2. 顺序结构,时间复杂度按加法进行计算
#     3. 循环结构,时间复杂度按乘法进行计算
#     4. 分支结构,时间复杂度取最大值
#     5. 判断一个算法的效率时,往往只需要关注操作数量的最高次项,其他次要项和常数项可以忽略
#     6. 在没有特殊说明时,分析算法时间复杂度都是最坏时间复杂度

# 常见时间复杂度与大小关系
#     执行次数函数举例    阶      非正式术语
#     123              O(1)    常数阶
#     2n + 3           O(n)    线性阶
#     n^2 + 2n + 1     O(n^2)  平方阶
#     logN + 20        O(logN) 对数阶
#     n^3 + 2n + 1     O(n^3)  立方阶
#     2^^n             O(2^^n) 指数阶

# 常见时间复杂度之间关系
#     TODO: 所消耗的时间从小到大
#     O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)


# 如果 a+b+c=1000,且a^2+b^2=c^2(a,b,c为自然数),求出所有a,b,c可能得组合?

# 方法一
import time

staTime = time.time()
ls = []
for a in range(1001):
    for b in range(1001):
        for c in range(1001):
            if a+b+c == 1000 and a**2 + b**2 == c**2:
                print(a, b, c)

# T(1000) = 1000*1000*1000*2
# T(n) = n**3*2

# T(n) = n**3

endTime = time.time()
print('spendTime', endTime-staTime)
print('Finished')

# 方法二
import time

staTime = time.time()

ls = []
for a in range(1001):
    for b in range(1001):
        c = 1000-a-b
        if a**2 + b**2 == c**2:
            print(a, b, c)

endTime = time.time()
print('spendTime', endTime-staTime)
print('Finished')

# 运行结果
#     0 500 500
#     200 375 425
#     375 200 425
#     500 0 500
#     spendTime 1.050462245941162
#     Finished

# 算法效率衡量
#     执行时间反应算法效率,实现算法的执行时间可以反应出算法的效率,即算法的优劣
